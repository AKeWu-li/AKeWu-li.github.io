---
title: GaussianUpdate
date: 2026-01-29 15:31:32
updated:
tags: ["3DGS"]
categories: 3D Reconstruction
keywords:
description:
top_img:
comments:
cover:
toc:
toc_number:
toc_style_simple:
copyright:
copyright_author:
copyright_author_href:
copyright_url:
copyright_info:
mathjax:
katex:
aplayer:
highlight_shrink:
aside:
abcjs:
noticeOutdate:
---

## 流程

一、 全局外观更新
全局外观模型：为了对光照引起的全局表观变化进行建模，使用一个4D哈希网格H和一个微小的MLP F作为全局表观模型来推断高斯图元上不同时刻的增量缩放和球谐性质
在Layout - Invariant区域进行外观更新：一般来说，全局光照主导了布局不变区域(即没有任何几何变化的静态区域)的外观变化。在第一阶段，我们的方法专注于通过单独优化4D哈希网格来更新这些变化。为了避免场景中可能出现的新物体或移除物体带来的影响，我们设计了一种鲁棒的方法来确定布局不变区域。具体来说，假设It f是新捕获的图像，我们可以用It f的相机姿态和先前的神经模型来渲染It - 1 f。那么对于这对对应的框架{ It f，It - 1f }，我们可以从一个基础模型SAM中得到它们的实例分割掩码{ St f，St - 1f }。 进一步，我们可以从{ St f，St-1 f }中计算相应实例之间的交并比( Intersection over Union，IoU )得分。在t和t - 1两个时间步Io U得分都较高的布局不变区域将被掩膜成{ Mtf，Mt-1f }。在当前时间步t，一个最终的布局不变量掩模Mf来自Mtf和Mt - 1f的交集，将用于指导后续的外观模型优化。结合该掩码Mf和光度损失，哈希编码外观模型可以在布局不变区域进行精确优化。通过排除所有可能的动态对象或部件，我们可以更好地学习全局外观模型，这进一步有利于后续的几何布局更新。
二、 几何布局更新
在几何布局发生变化的区域，需要优先生长和剪枝高斯基元，以拟合正确的几何形状，避免非预期的过拟合。对于新出现的物体，从COLMAP中产生新的高斯基元Gadd，并将其添加到现有的高斯场中。对于丢失的物体，我们设置可学习的移除因子m，它由一个函数ψ激活。值得注意的是，ψ ( m )仅乘以先前高斯函数Gp的不透明度。在此阶段，对Gadd的去除因子m和性质进行优化，如式( 1 )所示。11，同时保持上一阶段学习到的全局外观模型固定。
最终，我们设定阈值τ = 0。01识别候选高斯基元Gc ( ψ ( m ) < τ )予以移除。此外，我们进一步使用DBSCAN算法过滤掉Gc中远离缺失物体表面的稀疏离群点，并将剩余的高斯聚类成一个边界框，其中任何高斯从Gp中剪枝。与隐式神经场不同，我们的显式连续学习方法允许将剪枝后的高斯存储在可见性池中，用于可视化变化和回忆先前的场景模型。
三、 联合细化
在剪枝高斯基元后，渲染伪影不可避免地出现在被移除的物体周围。因此，在第三阶段，我们按照公式中的光度损失进行联合求精，共同优化Gadd的外观模型和性质。
重要度修枝：受[ 23 ]的启发，我们期望提取有价值的高斯来减少内存消耗。通过遍历当前时间步的所有训练视图，我们可以如下计算第i个高斯的重要性分数vi。

## 总结

### 输入现有模型

包含三个核心组件：

1) 3D Gaussians: 场景的几何表示（点云）
2) Visibility Mask (可见性掩码): 一个记录表，用于追踪每个高斯点在不同时间是否可见 。这是实现“记忆”功能的关键，使得模型可以随时回溯历史场景
3) 4D Hash (外观模型): 由特征哈希表 (Feature Hash Table) 和微型多层感知机 (Tiny MLP) 组成。它负责处理场景随时间发生的全局外观变化（如光照变化），而不改变几何结构

注1：Visibility Mask 本质上是一个二维的查找表，记录了每一个高斯球在每一个时刻是否处于激活状态。系统维护一个巨大的全局高斯池，这个池子包含了从 $T=0$ 到当前时刻 $T=N$ 所有出现过的高斯球的并集。即使会有两个高斯球在空间上的位置相同也没关系，反正一个时刻一个位置只会有一个高斯球处于激活状态。另外，对于布局不变只是光照变化的区域，并不会增加高斯点（而是利用4D Hash来处理）；在第三阶段的更新（即联合微调阶段），会计算每个高斯球对最终画面的贡献度（根据不透明度和累积透光率），如果太小，会进行删除。
注2：4D Hash的功能：输入为xyz坐标和t时间，然后将输入转换为切割的4D空间格点，得到整数（因为计算机无法处理无限精度的浮点数坐标），然后把这个整数通过哈希函数映射到特征哈希表格中(利用哈希函数)，也就是确定了放入表格中哪个位置，然后查找该位置周围角点的特征记录，经过线性插值后得到当前点的特征向量，将其输入到MLP中，得到输出：$\Delta s$ (大小的变化量) + $\Delta Y$ (颜色的变化量)。在三阶段更新中第一阶段全局外观更新中，会反向优化特征哈希表格中记录的特征向量。
注3：论文中提到的可见性感知持续学习指的就是全局高斯池和生成式回放机制

### 渲染过程（可渲染任一之前时刻的图像）

根据时间 $T$ 从 Visibility Mask 中筛选出当前时刻可见的 3D 高斯点，得到其基础属性（位置、旋转等）；根据时间T结合高斯点的3D坐标利用哈希函数计算其在哈希表中的位置，查询得到特征向量，输入到MLP中，计算得到颜色/光照 ($\Delta Y$) 和 缩放 ($\Delta S$) 的增量（这一步公式如下），叠加到基础属性中，然后通过光栅化渲染出图像。

$$\{ \Delta s, \Delta Y \} = \text{MLP}( \text{Hash}(\mu, t) )$$

注：这里的相机位姿是使用的COLMAP计算的或者数据集给出的，因为此任务不是本论文主要解决的问题，故未提及

### 变化检测与掩码生成

利用 SAM 模型分别对当前时刻的真实图像 ($T=N+1$) 和上一时刻的渲染图像 ($T=N$) 进行语义分割，然后分别通过($T=N$)计算($T=N+1$)IoU、通过($T=N+1$)计算($T=N$)IoU，（双向验证，这里是因为SAM进行语义分割的结果可能会有误差），并取交集，也就是标记出重叠区域，生成一个掩码，标记出那些物体依然存在、只是光照发生了变化的区域。这用于指导第一阶段的训练，防止在静态区域错误地修改几何结构。

### 三阶段更新

#### 全局外观更新

- 这个阶段会冻结 3D Gaussians，仅优化 4D Hash
- 使用 Masked Loss（即利用上面生成的 Unchanged Mask），只在布局未变的区域计算损失，避免受物体移动的干扰

#### 几何布局更新

- 这个阶段会冻结 4D Hash，仅优化 3D Gaussians
- 对于新出现的物体，利用 COLMAP 生成稀疏点云并添加到高斯场中
- 对于消失的物体，通过学习“移除因子”来修剪高斯点

注1：SplaTAM通常依赖 RGB-D 相机（深度图）。它知道那个地方是空的（深度突变），所以可以直接在那里生成点，或者基于渲染误差，在误差大的地方分裂点，但是如果深度图有噪声（比如黑色物体吸光、透明玻璃），或者在室外阳光下深度相机失效，SplaTAM 就会崩溃；如果没有深度图的话就可以像本论文一样借用COLMAP对新图像生成点云放进模型中，但实时性不强。
注2：系统不直接删除点，而是给每一个旧的高斯球 ($G_p$) 增加了一个可学习的参数 $m$，称为移除因子，如果某个高斯球挡住了现在的背景（比如车挡住了路），为了降低 Loss，网络会自动把这个球的 $m$ 值压低，让它变透明。另外，为了防止 $m$ 值卡在中间（半透明），引入了一个正则化项 $\mathcal{L}_{reg}$，强迫 $m$ 要么趋向 0（完全消失），要么趋向 1（完全保留），不许模棱两可。（这部分公式如下）当训练进行到一定程度，系统会找到所有 $\psi(m) < 0.01$（几乎全透明）的高斯球，标记为“候选删除点” ($G_c$)，然后使用 DBSCAN 聚类算法 检查这些候选点，只有当这些点聚集成一个“团簇”（Cluster）时，系统才认定这是一个“消失的物体”，并将其对应的区域画一个边界框，最后边界框内的旧高斯球会被正式从当前时刻的渲染列表中剔除（即在 Visibility Mask 中标记为 0），并存入可见性池。

$$\psi(m) = \frac{1}{1 + e^{-1000m}}$$

- $m$：每个高斯球可学习的“移除参数”
- $\psi(m)$：最终作用在不透明度上的乘数（0 到 1 之间）
- 标准的 Sigmoid 函数比较平滑，但这个系数1000让曲线变得极度陡峭，接近于一个阶跃函数。也就是系统不希望物体处于“半透明”状态。这个函数强迫高斯球的状态迅速两极分化：要么 $m$ 稍微大一点，$\psi(m)$ 就变成 1（完全保留）；要么 $m$ 稍微小一点，$\psi(m)$ 就变成 0（完全消失）

$$\mathcal{L}_{nd} = (1-\lambda_1)\mathcal{L}_{1} + \lambda_1\mathcal{L}_{D-SSIM} + \mathcal{L}_{reg}$$

- $\mathcal{L}_{1}$：L1 损失（像素颜色的绝对差值）
- $\mathcal{L}_{D-SSIM}$：结构相似性损失（D-SSIM）
- $\mathcal{M}_{f}$：布局不变掩码 (Layout-invariant Mask)（这里没有，这个是第一阶段用的）
- $\mathcal{L}_{reg}$：正则化项

$$\mathcal{L}_{reg} = \lambda_2 (1-\psi(m))\psi(m) + \lambda_3 \text{BCE}(\psi(m), 1)$$

- 第一项 $(1-\psi(m))\psi(m)$：当 $\psi(m)$ 为 0 或 1 时，该项为 0；当 $\psi(m)$ 为 0.5 时，该项最大
- 第二项 $\text{BCE}$：二元交叉熵
- 为了逼迫参数 $m$ 做出选择，惩罚那些“犹豫不决”的值（比如 0.5）

#### 联合微调

- 4D Hash 和 Updated GS (更新后的高斯点) 同时进行优化

注：这部分都是**利用可微渲染，对比当前时刻的真实图像和K时刻的渲染图像（即利用生成式回放策略防止遗忘）反向优化**

### 输出更新后的模型

依然是三个核心组件
